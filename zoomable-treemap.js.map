{"version":3,"file":"zoomable-treemap.js","sources":["../../../home/runner/work/metastanza/metastanza/stanzas/zoomable-treemap/index.js"],"sourcesContent":["// import * as d3 from \"d3\";\n// import data from \"./countries.json\";\n// const data = data.dataset;\n// console.log('dataset', dataset)\n// export default async function zoomableTreemap(stanza, params) {\n\n//   stanza.render({\n//     template: 'stanza.html.hbs',\n//     parameters: {\n//       greeting: `Hello, ${params['say-to']}!`\n//     }\n//   });\n\n//   //   window.addEventListener('message', function(e) {\n//   //     const opts = e.data.opts,\n\n//   //     return main(opts, data);\n//   // });\n\n//   // var defaults = {\n//   //   margin: { top: 24, right: 0, bottom: 0, left: 0 },\n//   //   rootname: \"TOP\",\n//   //   format: \",d\",\n//   //   title: \"\",\n//   //   width: 960,\n//   //   height: 500\n//   // };\n\n//   // function main(o, data) {\n//   //   var root,\n//   //     opts = $.extend(true, {}, defaults, o),\n//   //     formatNumber = d3.format(opts.format),\n//   //     rname = opts.rootname,\n//   //     margin = opts.margin,\n//   //     theight = 36 + 16;\n\n//   //   $('#chart').width(opts.width).height(opts.height);\n//   //   var width = opts.width - margin.left - margin.right,\n//   //     height = opts.height - margin.top - margin.bottom - theight,\n//   //     transitioning;\n\n//   //   var color = d3.scale.category20c();\n\n//   //   var x = d3.scale.linear()\n//   //     .domain([0, width])\n//   //     .range([0, width]);\n//   //   var y = d3.scale.linear()\n//   //     .domain([0, height])\n//   //     .range([0, height]);\n\n//   //   var treemap = d3.layout.treemap()\n//   //     .children(function (d, depth) { return depth ? null : d._children; })\n//   //     .sort(function (a, b) { return a.value - b.value; })\n//   //     .ratio(height / width * 0.5 * (1 + Math.sqrt(5)))\n//   //     .round(false);\n\n//   //   var svg = d3.select(\"#chart\").append(\"svg\")\n//   //     .attr(\"width\", width + margin.left + margin.right)\n//   //     .attr(\"height\", height + margin.bottom + margin.top)\n//   //     .style(\"margin-left\", -margin.left + \"px\")\n//   //     .style(\"margin.right\", -margin.right + \"px\")\n//   //     .append(\"g\")\n//   //     .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\n//   //     .style(\"shape-rendering\", \"crispEdges\");\n\n//   //   var grandparent = svg.append(\"g\")\n//   //     .attr(\"class\", \"grandparent\");\n\n//   //   grandparent.append(\"rect\")\n//   //     .attr(\"y\", -margin.top)\n//   //     .attr(\"width\", width)\n//   //     .attr(\"height\", margin.top);\n\n//   //   grandparent.append(\"text\")\n//   //     .attr(\"x\", 6)\n//   //     .attr(\"y\", 6 - margin.top)\n//   //     .attr(\"dy\", \".75em\");\n\n//   //   if (opts.title) {\n//   //     $(\"#chart\").prepend(\"<p class='title'>\" + opts.title + \"</p>\");\n//   //   }\n//   //   if (data instanceof Array) {\n//   //     root = { key: rname, values: data };\n//   //   } else {\n//   //     root = data;\n//   //   }\n\n//   //   initialize(root);\n//   //   accumulate(root);\n//   //   layout(root);\n//   //   console.log(root);\n//   //   display(root);\n\n//   //   if (window.parent !== window) {\n//   //     var myheight = document.documentElement.scrollHeight || document.body.scrollHeight;\n//   //     window.parent.postMessage({ height: myheight }, '*');\n//   //   }\n\n//   //   function initialize(root) {\n//   //     root.x = root.y = 0;\n//   //     root.dx = width;\n//   //     root.dy = height;\n//   //     root.depth = 0;\n//   //   }\n\n//   //   // Aggregate the values for internal nodes. This is normally done by the\n//   //   // treemap layout, but not here because of our custom implementation.\n//   //   // We also take a snapshot of the original children (_children) to avoid\n//   //   // the children being overwritten when when layout is computed.\n//   //   function accumulate(d) {\n//   //     return (d._children = d.values)\n//   //       ? d.value = d.values.reduce(function (p, v) { return p + accumulate(v); }, 0)\n//   //       : d.value;\n//   //   }\n\n//   //   // Compute the treemap layout recursively such that each group of siblings\n//   //   // uses the same size (1×1) rather than the dimensions of the parent cell.\n//   //   // This optimizes the layout for the current zoom state. Note that a wrapper\n//   //   // object is created for the parent node for each group of siblings so that\n//   //   // the parent’s dimensions are not discarded as we recurse. Since each group\n//   //   // of sibling was laid out in 1×1, we must rescale to fit using absolute\n//   //   // coordinates. This lets us use a viewport to zoom.\n//   //   function layout(d) {\n//   //     if (d._children) {\n//   //       treemap.nodes({ _children: d._children });\n//   //       d._children.forEach(function (c) {\n//   //         c.x = d.x + c.x * d.dx;\n//   //         c.y = d.y + c.y * d.dy;\n//   //         c.dx *= d.dx;\n//   //         c.dy *= d.dy;\n//   //         c.parent = d;\n//   //         layout(c);\n//   //       });\n//   //     }\n//   //   }\n\n//   //   function display(d) {\n//   //     grandparent\n//   //       .datum(d.parent)\n//   //       .on(\"click\", transition)\n//   //       .select(\"text\")\n//   //       .text(name(d));\n\n//   //     var g1 = svg.insert(\"g\", \".grandparent\")\n//   //       .datum(d)\n//   //       .attr(\"class\", \"depth\");\n\n//   //     var g = g1.selectAll(\"g\")\n//   //       .data(d._children)\n//   //       .enter().append(\"g\");\n\n//   //     g.filter(function (d) { return d._children; })\n//   //       .classed(\"children\", true)\n//   //       .on(\"click\", transition);\n\n//   //     var children = g.selectAll(\".child\")\n//   //       .data(function (d) { return d._children || [d]; })\n//   //       .enter().append(\"g\");\n\n//   //     children.append(\"rect\")\n//   //       .attr(\"class\", \"child\")\n//   //       .call(rect)\n//   //       .append(\"title\")\n//   //       .text(function (d) { return d.key + \" (\" + formatNumber(d.value) + \")\"; });\n//   //     children.append(\"text\")\n//   //       .attr(\"class\", \"ctext\")\n//   //       .text(function (d) { return d.key; })\n//   //       .call(text2);\n\n//   //     g.append(\"rect\")\n//   //       .attr(\"class\", \"parent\")\n//   //       .call(rect);\n\n//   //     var t = g.append(\"text\")\n//   //       .attr(\"class\", \"ptext\")\n//   //       .attr(\"dy\", \".75em\")\n\n//   //     t.append(\"tspan\")\n//   //       .text(function (d) { return d.key; });\n//   //     t.append(\"tspan\")\n//   //       .attr(\"dy\", \"1.0em\")\n//   //       .text(function (d) { return formatNumber(d.value); });\n//   //     t.call(text);\n\n//   //     g.selectAll(\"rect\")\n//   //       .style(\"fill\", function (d) { return color(d.key); });\n\n//   //     function transition(d) {\n//   //       if (transitioning || !d) return;\n//   //       transitioning = true;\n\n//   //       var g2 = display(d),\n//   //         t1 = g1.transition().duration(750),\n//   //         t2 = g2.transition().duration(750);\n\n//   //       // Update the domain only after entering new elements.\n//   //       x.domain([d.x, d.x + d.dx]);\n//   //       y.domain([d.y, d.y + d.dy]);\n\n//   //       // Enable anti-aliasing during the transition.\n//   //       svg.style(\"shape-rendering\", null);\n\n//   //       // Draw child nodes on top of parent nodes.\n//   //       svg.selectAll(\".depth\").sort(function (a, b) { return a.depth - b.depth; });\n\n//   //       // Fade-in entering text.\n//   //       g2.selectAll(\"text\").style(\"fill-opacity\", 0);\n\n//   //       // Transition to the new view.\n//   //       t1.selectAll(\".ptext\").call(text).style(\"fill-opacity\", 0);\n//   //       t1.selectAll(\".ctext\").call(text2).style(\"fill-opacity\", 0);\n//   //       t2.selectAll(\".ptext\").call(text).style(\"fill-opacity\", 1);\n//   //       t2.selectAll(\".ctext\").call(text2).style(\"fill-opacity\", 1);\n//   //       t1.selectAll(\"rect\").call(rect);\n//   //       t2.selectAll(\"rect\").call(rect);\n\n//   //       // Remove the old node when the transition is finished.\n//   //       t1.remove().each(\"end\", function () {\n//   //         svg.style(\"shape-rendering\", \"crispEdges\");\n//   //         transitioning = false;\n//   //       });\n//   //     }\n\n//   //     return g;\n//   //   }\n\n//   //   function text(text) {\n//   //     text.selectAll(\"tspan\")\n//   //       .attr(\"x\", function (d) { return x(d.x) + 6; })\n//   //     text.attr(\"x\", function (d) { return x(d.x) + 6; })\n//   //       .attr(\"y\", function (d) { return y(d.y) + 6; })\n//   //       .style(\"opacity\", function (d) { return this.getComputedTextLength() < x(d.x + d.dx) - x(d.x) ? 1 : 0; });\n//   //   }\n\n//   //   function text2(text) {\n//   //     text.attr(\"x\", function (d) { return x(d.x + d.dx) - this.getComputedTextLength() - 6; })\n//   //       .attr(\"y\", function (d) { return y(d.y + d.dy) - 6; })\n//   //       .style(\"opacity\", function (d) { return this.getComputedTextLength() < x(d.x + d.dx) - x(d.x) ? 1 : 0; });\n//   //   }\n\n//   //   function rect(rect) {\n//   //     rect.attr(\"x\", function (d) { return x(d.x); })\n//   //       .attr(\"y\", function (d) { return y(d.y); })\n//   //       .attr(\"width\", function (d) { return x(d.x + d.dx) - x(d.x); })\n//   //       .attr(\"height\", function (d) { return y(d.y + d.dy) - y(d.y); });\n//   //   }\n\n//   //   function name(d) {\n//   //     return d.parent\n//   //       ? name(d.parent) + \" / \" + d.key + \" (\" + formatNumber(d.value) + \")\"\n//   //       : d.key + \" (\" + formatNumber(d.value) + \")\";\n//   //   }\n//   // }\n\n//   // if (window.location.hash === \"\") {\n//   //   d3.json(\"countries.json\", function (err, res) {\n//   //     if (!err) {\n//   //       console.log(res);\n//   //       var data = d3.nest().key(function (d) { return d.region; }).key(function (d) { return d.subregion; }).entries(res);\n//   //       main({ title: \"World Population\" }, { key: \"World\", values: data });\n//   //     }\n//   //   });\n//   // }\n// }\n"],"names":[],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}